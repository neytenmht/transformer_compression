# -*- coding: utf-8 -*-
"""algebraic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OSGox86RcpRAR1DqTCEc3LVpcVh-JR0D
"""

import numpy as np
import matplotlib.pyplot as plt
import copy
import math
from scipy.linalg import svd

def low_rank_approximation(A, k):
    #Perform SVD on A
    U, S, Vt = np.linalg.svd(A, full_matrices=False)

    #Truncate the SVD components to rank k
    U_k = U[:, :k]          #First k columns of U
    S_k = S[:k]             #First k singular values
    Vt_k = Vt[:k, :]        #First k rows of Vt

    #Reconstruct the low-rank approximation
    A_k = U_k @ np.diag(S_k) @ Vt_k

    return A_k

def cumulative_sv(**kwargs):
    """
    Returns the normalized cumulative sum of singular values.

    Args:
        kwargs['sv_input'] (bool): True if input is singular values, False if input is a matrix
        kwargs['sv'] (np.ndarray): Array of singular values (required if sv_input is True)
        kwargs['matrix'] (np.ndarray): Input matrix (required if sv_input is False)

    Returns:
        np.ndarray: Normalized cumulative sum of singular values.
    """
    if 'sv_input' not in kwargs:
        raise ValueError("'sv_input' must be provided (True or False).")

    if kwargs['sv_input']:
        if 'sv' not in kwargs:
            raise ValueError("'sv' must be provided when sv_input is True.")
        sv = kwargs['sv']
    else:
        if 'matrix' not in kwargs:
            raise ValueError("'matrix' must be provided when sv_input is False.")
        A = kwargs['matrix']
        sv = np.linalg.svd(A, compute_uv=False)

    #Compute cumulative sum and normalize
    sv_cum = np.cumsum(sv)
    sv_cum_norm = sv_cum / sv_cum[-1]
    return sv_cum_norm

def proportion_above_threshold(arr, tau):
    """
    Calculate the proportion of values in an array that are above a given threshold

    Args :
      arr (np.ndarray) : Input array of values
      tau (float) : Threshold value

    Returns:
      proportion (float) : Proportion of values in `arr` that are greater than `tau`
    """

    arr = np.asarray(arr)
    count_above = np.sum(arr > tau)
    proportion = count_above / len(arr)

    return proportion


def rank_metric(M, metric='stable_rank'):
    """
    Computes a specified metric for a matrix M.

    Parameters:
    - M : numpy.ndarray, input matrix (m x n).
    - metric : str, options: 'stable_rank', 'numerical_rank', 'nuclear_norm'

    Returns:
    - Computed metric value (float or None if invalid).
    """
    m, n = M.shape
    sv = svd(M, compute_uv=False)  # Singular values (sorted in descending order)
    spectral_norm = sv[0] if len(sv) > 0 else 0  # ‖M‖ (largest singular value)

    # --- Compute selected metric ---
    if metric == 'stable_rank':
        return np.sum(sv**2) / (spectral_norm**2) if spectral_norm > 0 else 0

    elif metric == 'numerical_rank' :
      return np.linalg.matrix_rank(M)

    elif metric == 'nuclear_norm':
        nuclear_norm = np.sum(sv)
        return nuclear_norm

    elif metric == 'hard_threshold' :
        med_sv = np.median(sv)
        beta = param.shape[0]/param.shape[1]
        tau = optimal_SVHT_coef(beta, False)*med_sv
        return proportion_above_threshold(sv, tau)

    elif metric == 'effective_rank':
        total = np.sum(sv)
        if total == 0:
            return 0
        p = sv / total
        entropy = -np.sum(p * np.log(p + 1e-12))
        return np.exp(entropy)

    else:
        raise ValueError(
            f"Unknown metric: {metric}. Valid options are: "
            "'stable_rank', 'numerical_rank', 'nuclear_norm', 'hard_threshold', 'effective_rank'"
        )

def compute_sv_area(**kwargs):
    """
    Computes the area under the normalized cumulative singular value curve using the trapezoidal rule

    Args:
        kwargs['sv_input'] (Bool): True if inuput is singular values, False if input is a matrix
        kwargs['sv'] (np.ndarray): array of singular values
        kwargs['matrix'] (np.ndarray): intput matrix

    Returns:
        np.ndarray: Normalized cumulative sum of singular values
    """

    sv_cum_norm = cumulative_sv(**kwargs)
    d = np.linspace(0, 1, len(sv_cum_norm))
    area = np.trapz(sv_cum_norm, d)
    return area / (len(sv_cum_norm) / 2)